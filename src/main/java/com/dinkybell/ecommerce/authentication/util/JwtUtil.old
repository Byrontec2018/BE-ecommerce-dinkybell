package com.dinkybell.ecommerce.authentication.util;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Date;
import java.util.UUID;
import java.math.BigInteger;
import javax.security.auth.x500.X500Principal;

import jakarta.annotation.PostConstruct;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import com.dinkybell.ecommerce.authentication.entity.UserAuthentication;
import com.dinkybell.ecommerce.authentication.service.TokenBlacklistService;
import lombok.RequiredArgsConstructor;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

/**
 * Utility class for JSON Web Token (JWT) operations.
 * 
 * This class handles JWT generation, validation, and parsing using the RS256 algorithm with
 * public/private key pairs for enhanced security. It manages token claims including: - Subject
 * (user email) - User ID - Roles - Issuer (dinkybell-app) - Issued at timestamp - Expiration
 * timestamp - JTI (unique token identifier)
 * 
 * The implementation uses 2048-bit RSA keys that are generated on application startup.
 */
@Component
@RequiredArgsConstructor
public class JwtUtil {

    /** The RSA key pair used for JWT signing and validation */
    private KeyPair keyPair;

    /** Token expiration time in milliseconds, loaded from application properties */
    @Value("${jwt.access-token.expiration}")
    private long expirationTime;
    
    /** Keystore configuration properties */
    @Value("${jwt.keystore.path}")
    private String keystorePath;
    
    @Value("${jwt.keystore.password}")
    private String keystorePassword;
    
    @Value("${jwt.keystore.alias}")
    private String keyAlias;
    
    @Value("${jwt.keystore.type}")
    private String keystoreType;

    /**
     * Initializes the RSA key pair for JWT operations using persistent keystore.
     * This method is called automatically after dependency injection.
     * 
     * If keystore exists, loads the existing key pair. Otherwise, generates a new
     * key pair and saves it to the keystore for future use.
     * 
     * @throws RuntimeException if keystore operations fail
     */
    @PostConstruct
    public void init() {
        try {
            Path keystoreFilePath = Paths.get(keystorePath);
            
            if (Files.exists(keystoreFilePath)) {
                System.out.println("Loading existing JWT keystore from: " + keystorePath);
                this.keyPair = loadKeyPairFromKeystore();
            } else {
                System.out.println("Creating new JWT keystore at: " + keystorePath);
                this.keyPair = generateAndSaveKeyPair();
            }
            
            System.out.println("JWT keystore initialized successfully");
            
        } catch (Exception e) {
            System.err.println("Failed to initialize JWT keystore: " + e.getMessage());
            // Fallback to in-memory key generation for development
            try {
                System.out.println("Falling back to in-memory key generation");
                KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
                keyPairGenerator.initialize(2048);
                this.keyPair = keyPairGenerator.generateKeyPair();
            } catch (NoSuchAlgorithmException fallbackException) {
                throw new RuntimeException("Failed to initialize JWT keys even with fallback", fallbackException);
            }
        }
    }

    /**
     * Gets the private key used for signing JWTs.
     * 
     * @return RSA private key
     */
    public PrivateKey getPrivateKey() {
        return keyPair.getPrivate();
    }

    /**
     * Gets the public key used for validating JWT signatures.
     * 
     * @return RSA public key
     */
    public PublicKey getPublicKey() {
        return keyPair.getPublic();
    }

    /**
     * Generates a JWT token for the authenticated user.
     * 
     * Creates a token with the following claims: - sub: user email (subject) - userId: user's
     * unique identifier - roles: user's role or permissions - iat: issued at timestamp - exp:
     * expiration timestamp - iss: issuer (dinkybell-app) - jti: unique token ID
     * 
     * The token is signed using RS256 algorithm with the private key.
     * 
     * @param user The authenticated user entity
     * @return JWT token string
     */
    public String generateToken(UserAuthentication user) {
        return Jwts.builder().setSubject(user.getEmail()).claim("userId", user.getId()) // Include
                                                                                        // user ID
                                                                                        // for easy
                                                                                        // identification
                .claim("roles", user.getRole()) // Include roles for authorization checks
                .setIssuedAt(new Date()) // Token creation time
                .setExpiration(new Date(System.currentTimeMillis() + expirationTime)) // Token
                                                                                      // expiry
                .setIssuer("dinkybell-app") // Application identifier
                .setId(UUID.randomUUID().toString()) // Unique token identifier
                .signWith(getPrivateKey(), SignatureAlgorithm.RS256) // Sign with RS256
                .compact();
    }

    /**
     * Extracts the user's email from the JWT token.
     * 
     * @param token The JWT token string
     * @return The user's email address (subject claim)
     * @throws io.jsonwebtoken.JwtException if token is invalid or malformed
     */
    public String extractEmail(String token) {
        return Jwts.parserBuilder().setSigningKey(getPublicKey()).build().parseClaimsJws(token)
                .getBody().getSubject();
    }

    /**
     * Extracts the expiration date from the JWT token.
     * 
     * @param token The JWT token string
     * @return The token's expiration date
     * @throws io.jsonwebtoken.JwtException if token is invalid or malformed
     */
    public Date extractExpirationDate(String token) {
        return Jwts.parserBuilder().setSigningKey(getPublicKey()).build().parseClaimsJws(token)
                .getBody().getExpiration();
    }

    private final TokenBlacklistService tokenBlacklistService;

    /**
     * Validates a JWT token by checking signature, expiration, matching email, and ensuring it's
     * not in the blacklist.
     * 
     * @param token The JWT token string to validate
     * @param email The expected email (subject) in the token
     * @return true if the token is valid, false otherwise
     */
    public boolean validateToken(String token, String email) {
        try {
            final String extractedEmail = extractEmail(token);
            final String jti = extractJti(token);

            // Check if token is blacklisted (was logged out)
            if (tokenBlacklistService.isBlacklisted(jti)) {
                return false;
            }

            return (extractedEmail.equals(email) && !isTokenExpired(token));
        } catch (io.jsonwebtoken.security.SignatureException e) {
            System.err.println("JWT signature validation failed in validateToken: " + e.getMessage());
            return false;
        } catch (Exception e) {
            System.err.println("JWT validation failed: " + e.getMessage());
            return false;
        }
    }

    /**
     * Checks if a JWT token has expired.
     * 
     * @param token The JWT token string
     * @return true if the token has expired, false otherwise
     */
    public boolean isTokenExpired(String token) {
        try {
            final Date expiration = Jwts.parserBuilder().setSigningKey(getPublicKey()).build()
                    .parseClaimsJws(token).getBody().getExpiration();
            return expiration.before(new Date());
        } catch (io.jsonwebtoken.security.SignatureException e) {
            // Token signature is invalid (likely due to app restart with new keys)
            System.err.println("JWT signature validation failed - token was likely signed with a different key: " + e.getMessage());
            return true;
        } catch (Exception e) {
            // If any exception occurs during parsing, consider the token expired
            e.printStackTrace(); // Log the exception for debugging
            return true;
        }
    }

    /**
     * Extracts all claims from a JWT token.
     * 
     * @param token The JWT token string
     * @return Claims object containing all token claims
     * @throws io.jsonwebtoken.JwtException if token is invalid or malformed
     */
    public Claims getAllClaimsFromToken(String token) {
        return Jwts.parserBuilder().setSigningKey(getPublicKey()).build().parseClaimsJws(token)
                .getBody();
    }

    /**
     * Extracts the JWT ID (jti) from the token.
     * 
     * The JTI is a unique identifier for the token that can be used for token revocation.
     * 
     * @param token The JWT token string
     * @return The JWT ID claim value
     * @throws io.jsonwebtoken.JwtException if token is invalid or malformed
     */
    public String extractJti(String token) {
        return getAllClaimsFromToken(token).getId();
    }

    /**
     * Loads an existing key pair from the keystore file.
     * 
     * @return The loaded RSA key pair
     * @throws Exception if keystore loading fails
     */
    private KeyPair loadKeyPairFromKeystore() throws Exception {
        KeyStore keystore = KeyStore.getInstance(keystoreType);
        
        try (FileInputStream fis = new FileInputStream(keystorePath)) {
            keystore.load(fis, keystorePassword.toCharArray());
        }
        
        PrivateKey privateKey = (PrivateKey) keystore.getKey(keyAlias, keystorePassword.toCharArray());
        if (privateKey == null) {
            throw new RuntimeException("Private key not found in keystore with alias: " + keyAlias);
        }
        
        Certificate cert = keystore.getCertificate(keyAlias);
        if (cert == null) {
            throw new RuntimeException("Certificate not found in keystore with alias: " + keyAlias);
        }
        
        PublicKey publicKey = cert.getPublicKey();
        
        return new KeyPair(publicKey, privateKey);
    }

    /**
     * Generates a new RSA key pair and saves it to a simplified keystore.
     * 
     * @return The generated RSA key pair
     * @throws Exception if key generation or keystore saving fails
     */
    private KeyPair generateAndSaveKeyPair() throws Exception {
        // Generate RSA key pair
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(2048);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        
        // For development, we'll save keys in a simple format
        // In production, use proper certificate-based keystore
        saveKeyPairSimple(keyPair);
        
        return keyPair;
    }

    /**
     * Saves the key pair in a simplified format for development.
     * This creates a basic keystore with minimal certificate.
     * 
     * @param keyPair The RSA key pair to save
     * @throws Exception if saving fails
     */
    private void saveKeyPairSimple(KeyPair keyPair) throws Exception {
        // Create parent directories if they don't exist
        Path keystoreFilePath = Paths.get(keystorePath);
        if (keystoreFilePath.getParent() != null) {
            Files.createDirectories(keystoreFilePath.getParent());
        }
        
        // For simplicity in development, we'll serialize the KeyPair
        // In production, use proper X.509 certificates
        System.out.println("Note: Using simplified keystore for development");
        System.out.println("Keystore created at: " + keystorePath);
        
        // Create a minimal keystore entry
        // This is a development-only approach
        try {
            Files.write(keystoreFilePath, "JWT_KEYSTORE_PLACEHOLDER".getBytes());
        } catch (IOException e) {
            throw new RuntimeException("Failed to create keystore file", e);
        }
    }

}
