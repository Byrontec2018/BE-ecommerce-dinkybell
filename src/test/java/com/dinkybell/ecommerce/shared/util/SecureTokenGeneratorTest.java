package com.dinkybell.ecommerce.shared.util;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.RepeatedTest;

import java.util.Base64;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;

import static org.assertj.core.api.Assertions.*;

/**
 * Unit tests for {@link SecureTokenGenerator}.
 * 
 * These tests verify the cryptographic security, randomness, and format
 * of tokens generated by the SecureTokenGenerator utility class.
 * 
 * Test coverage includes:
 * - Token format validation (Base64 URL-safe encoding)
 * - Length verification for different token types
 * - Uniqueness verification (collision resistance)
 * - Exception handling for invalid inputs
 * - Performance characteristics
 * 
 * @author Dinkybell Development Team
 */
@DisplayName("SecureTokenGenerator Tests")
class SecureTokenGeneratorTest {

    /**
     * Pattern for validating Base64 URL-safe encoding.
     * Base64 URL-safe alphabet: A-Z, a-z, 0-9, -, _
     * No padding characters (=) are allowed.
     */
    private static final Pattern BASE64_URL_PATTERN = Pattern.compile("^[A-Za-z0-9_-]+$");

    /**
     * Tests that the default token generation produces valid Base64 URL-safe tokens.
     * 
     * Verifies:
     * - Token is not null or empty
     * - Token matches Base64 URL-safe character set
     * - No padding characters are present
     */
    @Test
    @DisplayName("Should generate valid Base64 URL-safe token with default length")
    void shouldGenerateValidBase64UrlToken() {
        // When
        String token = SecureTokenGenerator.generateToken();

        // Then
        assertThat(token)
                .isNotNull()
                .isNotEmpty()
                .matches(BASE64_URL_PATTERN)
                .doesNotContain("=", "+", "/");
    }

    /**
     * Tests that default tokens have the expected length.
     * 
     * 32 bytes of random data encoded in Base64 should produce ~43 characters.
     * Base64 encoding overhead: 4 characters for every 3 bytes.
     * Formula: ceil(bytes * 4 / 3) = ceil(32 * 4 / 3) = ceil(42.67) = 43
     */
    @Test
    @DisplayName("Should generate token with expected length for 32 bytes")
    void shouldGenerateTokenWithExpectedLength() {
        // When
        String token = SecureTokenGenerator.generateToken();

        // Then
        assertThat(token).hasSize(43);
    }

    /**
     * Tests that short tokens (16 bytes, 128 bits) have the expected length.
     * 
     * 16 bytes encoded in Base64 should produce ~22 characters.
     * Formula: ceil(16 * 4 / 3) = ceil(21.33) = 22
     */
    @Test
    @DisplayName("Should generate short token with expected length for 16 bytes")
    void shouldGenerateShortTokenWithExpectedLength() {
        // When
        String token = SecureTokenGenerator.generateShortToken();

        // Then
        assertThat(token)
                .isNotNull()
                .hasSize(22)
                .matches(BASE64_URL_PATTERN);
    }

    /**
     * Tests that long tokens (32 bytes, 256 bits) have the expected length.
     * 
     * This is the same as the default token length.
     */
    @Test
    @DisplayName("Should generate long token with expected length for 32 bytes")
    void shouldGenerateLongTokenWithExpectedLength() {
        // When
        String token = SecureTokenGenerator.generateLongToken();

        // Then
        assertThat(token)
                .isNotNull()
                .hasSize(43)
                .matches(BASE64_URL_PATTERN);
    }

    /**
     * Tests custom token length generation.
     * 
     * Verifies that tokens generated with custom byte lengths produce
     * the mathematically expected Base64 string length.
     */
    @Test
    @DisplayName("Should generate token with custom length")
    void shouldGenerateTokenWithCustomLength() {
        // When - 8 bytes should produce ceil(8 * 4 / 3) = 11 characters
        String token8 = SecureTokenGenerator.generateToken(8);
        // When - 64 bytes should produce ceil(64 * 4 / 3) = 86 characters
        String token64 = SecureTokenGenerator.generateToken(64);

        // Then
        assertThat(token8)
                .hasSize(11)
                .matches(BASE64_URL_PATTERN);
        assertThat(token64)
                .hasSize(86)
                .matches(BASE64_URL_PATTERN);
    }

    /**
     * Tests that tokens are cryptographically unique (collision resistant).
     * 
     * Generates 1000 tokens and verifies that all are unique.
     * With 256 bits of entropy, the probability of collision in 1000 tokens
     * is astronomically low (~10^-72).
     */
    @Test
    @DisplayName("Should generate unique tokens (no collisions)")
    void shouldGenerateUniqueTokens() {
        // Given
        Set<String> tokens = new HashSet<>();
        int tokenCount = 1000;

        // When - Generate 1000 tokens
        for (int i = 0; i < tokenCount; i++) {
            tokens.add(SecureTokenGenerator.generateToken());
        }

        // Then - All tokens should be unique
        assertThat(tokens).hasSize(tokenCount);
    }

    /**
     * Tests that repeated token generation produces different results.
     * 
     * This test runs 10 times to verify randomness. Each run generates
     * two consecutive tokens and verifies they are different.
     */
    @RepeatedTest(10)
    @DisplayName("Should generate different tokens on consecutive calls")
    void shouldGenerateDifferentTokens() {
        // When
        String token1 = SecureTokenGenerator.generateToken();
        String token2 = SecureTokenGenerator.generateToken();

        // Then
        assertThat(token1).isNotEqualTo(token2);
    }

    /**
     * Tests that tokens with different lengths are different.
     * 
     * Verifies that short and long tokens have different characteristics
     * and content.
     */
    @Test
    @DisplayName("Should generate different tokens for short and long types")
    void shouldGenerateDifferentTokenTypesWithDifferentLengths() {
        // When
        String shortToken = SecureTokenGenerator.generateShortToken();
        String longToken = SecureTokenGenerator.generateLongToken();

        // Then
        assertThat(shortToken)
                .isNotEqualTo(longToken)
                .hasSizeLessThan(longToken.length());
    }

    /**
     * Tests that token generation fails with invalid input.
     * 
     * Verifies that requesting a token with 0 or negative byte length
     * throws an IllegalArgumentException.
     */
    @Test
    @DisplayName("Should throw exception for invalid token length")
    void shouldThrowExceptionForInvalidLength() {
        // When/Then - Zero bytes
        assertThatThrownBy(() -> SecureTokenGenerator.generateToken(0))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Token length must be at least 1 byte");

        // When/Then - Negative bytes
        assertThatThrownBy(() -> SecureTokenGenerator.generateToken(-1))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Token length must be at least 1 byte");
    }

    /**
     * Tests that the utility class cannot be instantiated.
     * 
     * Verifies that attempting to instantiate SecureTokenGenerator
     * via reflection throws an UnsupportedOperationException wrapped
     * in an InvocationTargetException.
     */
    @Test
    @DisplayName("Should not allow instantiation of utility class")
    void shouldNotAllowInstantiation() {
        // When/Then
        assertThatThrownBy(() -> {
            var constructor = SecureTokenGenerator.class.getDeclaredConstructor();
            constructor.setAccessible(true);
            constructor.newInstance();
        })
        .isInstanceOf(java.lang.reflect.InvocationTargetException.class)
        .hasCauseInstanceOf(UnsupportedOperationException.class)
        .hasRootCauseMessage("Utility class cannot be instantiated");
    }

    /**
     * Tests token entropy by verifying character distribution.
     * 
     * Generates a large token (256 bytes) and verifies that:
     * - Multiple different characters are used (not all the same)
     * - Distribution is relatively balanced (no excessive repetition)
     * 
     * This is a sanity check for randomness, not a rigorous statistical test.
     */
    @Test
    @DisplayName("Should generate tokens with good entropy (character distribution)")
    void shouldGenerateTokensWithGoodEntropy() {
        // When - Generate a large token for better statistical analysis
        String token = SecureTokenGenerator.generateToken(256); // 342 characters

        // Then - Verify diverse character set is used
        Set<Character> uniqueChars = new HashSet<>();
        for (char c : token.toCharArray()) {
            uniqueChars.add(c);
        }

        // A random 256-byte token should have high character diversity
        // We expect at least 40 different characters from the 64-character alphabet
        assertThat(uniqueChars).hasSizeGreaterThanOrEqualTo(40);
    }

    /**
     * Tests that tokens can be decoded back to byte arrays.
     * 
     * Verifies that generated tokens are valid Base64 URL-safe encodings
     * by attempting to decode them back to bytes.
     */
    @Test
    @DisplayName("Should generate tokens that can be decoded as Base64 URL-safe")
    void shouldGenerateDecodableTokens() {
        // When
        String token = SecureTokenGenerator.generateToken();

        // Then - Should decode without throwing exception
        assertThatCode(() -> {
            Base64.getUrlDecoder().decode(token);
        }).doesNotThrowAnyException();
    }

    /**
     * Tests that decoded tokens have the expected byte length.
     * 
     * Verifies that generating a token with N bytes and decoding it
     * produces exactly N bytes of random data.
     */
    @Test
    @DisplayName("Should generate tokens that decode to expected byte length")
    void shouldGenerateTokensWithExpectedByteLength() {
        // When
        int expectedBytes = 32;
        String token = SecureTokenGenerator.generateToken(expectedBytes);
        byte[] decodedBytes = Base64.getUrlDecoder().decode(token);

        // Then
        assertThat(decodedBytes).hasSize(expectedBytes);
    }

    /**
     * Tests token generation performance.
     * 
     * Verifies that generating 1000 tokens completes within a reasonable time
     * (< 500ms on modern hardware). This ensures the generator is suitable
     * for production use under load.
     */
    @Test
    @DisplayName("Should generate tokens in reasonable time")
    void shouldGenerateTokensInReasonableTime() {
        // When
        long startTime = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            SecureTokenGenerator.generateToken();
        }
        long endTime = System.nanoTime();
        long durationMs = (endTime - startTime) / 1_000_000;

        // Then - Should complete in less than 500ms
        assertThat(durationMs).isLessThan(500L);
    }
}
